### A Pluto.jl notebook ###
# v0.12.21

using Markdown
using InteractiveUtils

# ╔═╡ 0d201414-840e-11eb-1267-65b12044e222
begin
	using PlutoUI, StringEncodings, Printf
	
	task_n = 516439217617
	task_e1 = 1206433
	task_e2 = 1141277
	task_c1 = [400408320444 241545246801 282223079755 490328978748 350509811006 142356755075 109547314116 414823859933 330990395685 377471732609 44017319588 499241372980 171071879560]
	task_c2 = [374984721363 438491303024 498951362977 218681974856 365827206348 175049781656 359111505460 297734746741 96963152197 362138584797 102758207364 37817394150 120430068125]
	
	md"""
	# Лабораторная работа №4. Атака на алгоритм шифрования RSA методом бесключевого чтения

	## Цель работы

	Изучить атаку на алгоритм шифрования RSA посредством метода бесключевого чтения.

	## Задание

	Вариант 7:
	* Модуль $n$: $(task_n)
	* Экспоненты $e$: $(task_e1) $(task_e2)
	* Блок зашифрованного текста $C1$: $(join(task_c1, " "))
	* Блок зашифрованного текста $C2$: $(join(task_c2, " "))
	
	## Алгоритм шифрования RSA
	
	1. Выбираются два больших простых числа $p$ и $q$, вычисляется $n = pq$.
	2. Вычисляется $\phi(n) = (p - 1)(q - 1)$.
	3. Находится любое число $e$, которое является взаимно простым $\phi(n)$: $\{ e \in \mathbb{Z} \mid \gcd(e, \phi(n)) = 1, 1 < e < \phi(n) \}$.
	4. Вычисляется такое число $d$, что $de$ сравнимо с единицей по модулю $\phi(n)$: $\{ d \in \mathbb{Z} \mid de \equiv 1 \pmod{\phi(n)} \}$.
	
	Пара $(n, e)$ является публичным ключом, который используется для шифрования. Сообщение разделяется на блоки $t, t < n$, для каждого из которых вычисляется $c = t^e \mod n$.
	
	Пара $(n, d)$ является приватным ключом, который используется для дешифрования: $t = c^d \mod n$.
	
	## Атака на алгоритм RSA
	
	Известны $(n, e)$ — публичный ключ, $c$ — зашифрованные данные. Необходимо найти $d$ путем факторизации $n$, т.е. нахождения $p$ и $q$. При правильном выборе чисел данная задача является вычислительно сложной.
	
	Однако если известны два зашифрованных сообщения, $с_1 = t^{e_1} \pmod{n}$, $с_2 = t^{e_2} \pmod{n}$, содержание $t$ которых одинаково и при шифровании которых использовался один и тот же модуль $n$, но разные экспоненты $e_1$ и $e_2$, то исходное сообщение $t$ может быть восстановлено методом бесключевого чтения.
	
	Атака основывается на наблюдении, что $e_1$ и $e_2$ взаимно просты, т.е. можно найти такие целочисленные $r$ и $s$, что $re_1 + se_2 = 1$ (соотношение Безу для взаимно простых чисел). В таком случае $с_1^r \cdot c_2^s = t^{re_1+se_2} = t \pmod{n}$.
	"""
end

# ╔═╡ 3c5d32c4-8426-11eb-0a7f-255bc8bf2a8a
# Finds Bézout coefficients for coprime e1 and e2,
# i.e. a pair of (r, s) such that e1*r + e2*s = 1.
# For positive e1 and e2, r will be positive and s will be negative
function solve_rs(e1, e2)::Tuple{Int64,Int64}
	r = 0
	while true
		# e1*r + e2*s = 1
		r += 1
		s = (1 - e1*r)/e2
		if isinteger(s)
			return (r, s)
		end
	end
end

# ╔═╡ 122552ea-841a-11eb-29aa-ef53d59e2885
with_terminal() do
	r, s = solve_rs(task_e1, task_e2)
	
	print("Given n = $(task_n)\n")
	print("Given public key exponents e1 = $(task_e1), e2 = $(task_e2)\n\n")
 	print("Computed r = $(r), s = $(s) for r*e1 + s*e2 = 1\n\n")
	print("Decoding C:\n")
	
	msg = []
	
	for (c1, c2) in zip(task_c1, task_c2)
		c1_r::BigInt = powermod(c1, r, task_n)
		c2_s::BigInt = powermod(c2, s, task_n)
		t = mod(c1_r*c2_s, task_n)
		
		chars = [(t >> 24) % UInt8, (t >> 16) % UInt8, (t >> 8) % UInt8, t % UInt8]
		textchars = decode(chars, "WINDOWS-1251")
		
		@printf("c1 = %012d, c2 = %012d, c1^r = %012d, c2^s = %012d\n",
			c1, c2, c1_r, c2_s)
		@printf("t = c1^r * c2^s (mod n) = %010d = %s = |%s|\n",
			t, join(map(n -> string(n, base=16), chars), " "), textchars)
		
		append!(msg, textchars)
	end
	
	print("\nDecoded message:\n$(join(msg))")
end

# ╔═╡ Cell order:
# ╟─0d201414-840e-11eb-1267-65b12044e222
# ╠═122552ea-841a-11eb-29aa-ef53d59e2885
# ╠═3c5d32c4-8426-11eb-0a7f-255bc8bf2a8a
