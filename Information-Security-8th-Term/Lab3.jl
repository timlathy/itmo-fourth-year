### A Pluto.jl notebook ###
# v0.12.21

using Markdown
using InteractiveUtils

# ╔═╡ 70c2ff74-8239-11eb-381b-f316901ae8be
begin
	using PlutoUI, StringEncodings
	
	task_n = 84032429242009
	task_e = 2581907
	task_c = [54879925681459, 72167008182929, 17828219756166, 17814399744948, 37136636080011, 77223434260215, 4272415279426, 73759271926435, 74021335775875, 16903113250201, 77520052156956, 41247980943013]
	
	md"""
	# Лабораторная работа №3. Атака на алгоритм шифрования RSA посредством метода Ферма

	## Цель работы

	Изучить атаку на алгоритм шифрования RSA посредством метода факторизации Ферма.

	## Задание

	Вариант 7:
	* Модуль $n$: $(task_n)
	* Экспонента $e$: $(task_e)
	* Блок зашифрованного текста $C$: $(join(task_c, " "))
	
	## Алгоритм шифрования RSA
	
	1. Выбираются два больших простых числа $p$ и $q$, вычисляется $n = pq$.
	2. Вычисляется $\phi(n) = (p - 1)(q - 1)$.
	3. Находится любое число $e$, которое является взаимно простым $\phi(n)$: $\{ e \in \mathbb{Z} \mid \gcd(e, \phi(n)) = 1, 1 < e < \phi(n) \}$.
	4. Вычисляется такое число $d$, что $de$ сравнимо с единицей по модулю $\phi(n)$: $\{ d \in \mathbb{Z} \mid de \equiv 1 \pmod{\phi(n)} \}$.
	
	Пара $(n, e)$ является публичным ключом, который используется для шифрования. Сообщение разделяется на блоки $t, t < n$, для каждого из которых вычисляется $c = t^e \mod n$.
	
	Пара $(n, d)$ является приватным ключом, который используется для дешифрования: $t = c^d \mod n$.
	
	## Атака на алгоритм RSA
	
	Известны $(n, e)$ — публичный ключ, $c$ — зашифрованные данные. Необходимо найти $d$ путем факторизации $n$, т.е. нахождения $p$ и $q$. При правильном выборе чисел данная задача является вычислительно сложной, однако если $p$ и $q$ близки друг к другу, то они могут быть найдены за небольшое число шагов методом факторизации Ферма.
	
	Атака состоит в решении уравнения $t^2 - w^2 = n$, т.е. поиске такого $t$, что $t^2 - n$ является квадратом целого числа. Поиск начинается с $t = [\sqrt{n}]$ — наименьшего $t$, при котором $t^2 - n \geqslant 0$. На каждой итерации к $t$ прибавляется 1 и вычисляется $w^2 = t^2 - n$. Если полученное значение является квадратом целого $w$, то $p = t + w$ и $q = t - w$. Зная $p$ и $q$, можно вычислить $d$, следуя шагам 2-4 алгоритма шифрования.
	"""
end

# ╔═╡ 722eed4e-823b-11eb-08b0-bd1bf555568b
with_terminal() do
	print("Given public key (n, e): ($(task_n), $(task_e))\n")
	print("Breaking private key (n, d):\n\n")
	
	t::UInt64 = round(sqrt(task_n))
	w::Float64 = 0.0

	iter = 1
	while true
		t += 1
		w2 = t^2 - task_n
		w = sqrt(w2)
		print("Iter $(iter): t = $(t), w^2 = t^2 - n = $(w2), w = $(w)\n")
		
		if isinteger(w)
			break
		end
		
		iter += 1
	end

	p::UInt64 = t + w
	print("\np = t + w = $(p)\n")
	q::UInt64 = t - w
	print("q = t - w = $(q)\n")
	phi_n::UInt64 = (p - 1)*(q - 1)
	print("phi(n) = (p - 1)(q - 1) = $(phi_n)\n")
	d = invmod(task_e, phi_n)
	print("d = e^-1 mod phi(n) = $(d)\n")
	
	print("Computed private key (n, d): ($(task_n), $(d))\n\n")
	print("Decoding C:\n")
	
	msg = []

	for c in task_c
		c_::UInt64 = powermod(c, d, task_n)
		chs = [(c_ >> 24) % UInt8, (c_ >> 16) % UInt8, (c_ >> 8) % UInt8, c_ % UInt8]
		textchs = decode(chs, "WINDOWS-1251")
		print("c = $(c),\tc' = c^d mod n = $(c_)\t= |$(textchs)|\n")
		append!(msg, textchs)
	end
	
	print("\nDecoded message:\n$(join(msg))")
end

# ╔═╡ Cell order:
# ╟─70c2ff74-8239-11eb-381b-f316901ae8be
# ╠═722eed4e-823b-11eb-08b0-bd1bf555568b
